"""
Copyright (c) 2017, Jairus Martin.

Distributed under the terms of the GPL v3 License.

The full license is in the file LICENSE, distributed with this software.

Created on Dec 10, 2015

@author: jrm
"""
import os
from enaml.widgets.api import  Container, Timer, MultilineField, Menu, Action
from enaml.scintilla.api import Scintilla, ScintillaIndicator, ScintillaMarker
from enaml.scintilla.themes import THEMES
from enaml.scintilla.mono_font import MONO_FONT
from enaml.application import deferred_call
from declaracad.core.api import DockItem
from declaracad.core.utils import load_icon, load_image
from .plugin import Document


def format_title(docs, doc, path, unsaved):
    """ Attempt to format the title using the shortest unique name that
    does not conflict with any other opened documents.

    Based on Intellij's naming styles
    """
    if not path:
        return "Untitled*"
    path, name = os.path.split(path)

    #: Find any others with the same name
    duplicates = [d.name for d in docs
                    if d != doc and os.path.split(d.name)[-1] == name]

    #: Add folders until it becomes unique we run out of folders
    if duplicates:
        sep = os.path.sep
        parts = path.split(sep)
        for i in reversed(range(len(parts))):
            tmp_name = sep.join(parts[i:])

            #: See if there's still duplicates
            duplicates = [d for d in duplicates if d.endswith(tmp_name)]
            if not duplicates:
                name = os.path.join(tmp_name, name)
                break

        #: Give up
        if duplicates:
            name += "({})".format(len(duplicates))

    if unsaved:
        name += "*"
    return name


def detect_syntax(path):
    p, ext = os.path.splitext(path)
    file_type = ext[1:] if ext else ''
    SYNTAXES = Scintilla.syntax.items
    if file_type in SYNTAXES:
        return file_type
    elif file_type in ['py', 'pyx']:
        return 'python'
    elif file_type in ['js', 'ts', 'jsx']:
        return 'javascript'
    elif file_type in ['ino']:
        return 'cpp'
    elif file_type in ['sh']:
        return 'bash'
    return ''


def create_indicators(errors):
    results = []
    try:
        for e in errors:
            tag = e.split(":")[0:3]
            if len(tag) < 2:
                continue
            try:
                l = int(tag[1])
            except ValueError:
                continue

            color = "#FF0000"
            try:
                c = int(tag[2])
                start = (l-1, 0)
                stop = (l-1, c)
            except ValueError:
                start = (l-1, 0)
                stop = (l, 0)
                color = "#FFFF00"

            results.append(ScintillaIndicator(
                start=start, stop=stop, style="squiggle", color=color,
            ))
    except Exception as e:
        print(e)
    return results


enamldef Editor(Container): view:
    padding = 0
    alias editor
    Scintilla: editor:
        hug_height = 'ignore'
        hug_width = 'ignore'
        syntax << detect_syntax(doc.name)
        attr editor_font: str << f"{plugin.font_size}pt {plugin.font_family}"
        
        func update_font(theme, font):
            theme['settings']['font'] = font
            return theme
        
        theme  << update_font(THEMES[plugin.theme] if plugin else THEMES['tango'], 
                              editor_font)
        settings = {
            "tab_width": 4,
            "use_tabs": False,
            "indent": 4,
            "tab_indents": True,
            "auto_indent": True,
            "backspace_unindents": True,
            "autocompletion_threshold": 1,
            "autocompletion_case_sensitive": True,
            "show_line_numbers": True,
        }
        autocomplete = 'all'
        activated :: set_text(doc.source)
        text_changed :: timer.start()
        zoom << plugin.zoom if plugin else 0
        indicators << create_indicators(doc.errors) if doc else []
        markers << [ScintillaMarker(
                        line=i.start[0],
                        image=load_image("exclamation" if i.color=="#FF0000"
                                         else "error"))
                        for i in indicators]
        #warnings
        Timer: timer:
            interval = 350
            single_shot = True
            timeout ::
                doc.cursor = editor.cursor_position
                doc.source = editor.get_text()
                editor.autocompletions = doc.suggestions



enamldef EditorDockItem(DockItem): view:
    attr doc: Document = Document()
    alias buffer: editor.editor.document
    title << format_title(plugin.documents, doc, doc.name, doc.unsaved)
    closed ::
        core = plugin.workbench.get_plugin("enaml.workbench.core")
        core.invoke_command('declaracad.editor.close_editor',
                            {'document':doc, 'target': view.name})
    icon = load_icon('script_code')
    name = 'editor-item-{}'.format(id(self))
    Editor: editor:
        minimum_size = (480, 320)
    title_bar_right_clicked :: menu.popup()
    Menu: menu:
        Action:
            text = "Split vertically"
            triggered ::
                core = plugin.workbench.get_plugin("enaml.workbench.core")
                core.invoke_command('declaracad.editor.new_editor',
                                    {'document':doc, 'target': view.name,
                                     'buffer': view.buffer,
                                     'position': 'bottom'})
        Action:
            text = "Split horizontally"
            triggered ::
                core = plugin.workbench.get_plugin("enaml.workbench.core")
                core.invoke_command('declaracad.editor.new_editor',
                                    {'document':doc, 'target': view.name,
                                     'buffer': view.buffer,
                                     'position': 'right'})
        Action:
            separator = True
        Action:
            text = "New viewer"
        Action:
            separator = True
        Action:
            text = "Close"
            triggered ::
                core = plugin.workbench.get_plugin("enaml.workbench.core")
                core.invoke_command('declaracad.editor.close_editor',
                                    {'document':doc, 'target': view.name,})
        Action:
            text = "Close all"
            triggered ::
                core = plugin.workbench.get_plugin("enaml.workbench.core")
                deferred_call(core.invoke_command, 'declaracad.editor.close_all_editors')
        Action:
            text = "Close all others"
            triggered ::
                core = plugin.workbench.get_plugin("enaml.workbench.core")
                deferred_call(core.invoke_command, 'declaracad.editor.close_other_editors',
                                    {'editor': view})


enamldef ErrorsDockItem(DockItem):
  title = "Errors"
  name = 'errors-item'
  icon = load_icon('bug')
  Container:
      padding = 0
      MultilineField:
          text << "\n".join(plugin.active_document.errors)


enamldef OutputDockItem(DockItem):
  title = "Output"
  name = 'script-output-item'
  icon = load_icon('script')
  Container:
      padding = 0
      MultilineField:
          text << "\n".join(plugin.active_document.output)
